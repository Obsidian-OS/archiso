#!/usr/bin/env python3
import argparse
import shutil
import shlex
import sys
import os
import subprocess
import re

def check_dependencies(commands):
    commands.extend(["curl", "tar"])
    for command in commands:
        if not shutil.which(command):
            print(f"Error: Required command '{command}' not found.", file=sys.stderr)
            sys.exit(1)
def checkroot():
    if os.geteuid() != 0:
      print("This script must be run as root.", file=sys.stderr)
      sys.exit(1)

def run_command(command, **kwargs):
    kwargs.setdefault("text", True)
    check = kwargs.pop("check", True)
    try:
        process = subprocess.run(
            command if isinstance(command, list) else shlex.split(command),
            check=check,
            **kwargs,
        )
        return process
    except subprocess.CalledProcessError as e:
        print(f"Error executing command: {command}", file=sys.stderr)
        print(f"Exit Code: {e.returncode}", file=sys.stderr)
        if e.stdout:
            print(f"Stdout: {e.stdout}", file=sys.stderr)
        if e.stderr:
            print(f"Stderr: {e.stderr}", file=sys.stderr)
        sys.exit(1)
    except FileNotFoundError:
        print(f"Error: Command not found for: {command}", file=sys.stderr)
        sys.exit(1)


def _get_part_path(device, part_num):
    if "nvme" in device:
        return f"{device}p{part_num}"
    else:
        return f"{device}{part_num}"


def get_current_slot_systemd():
    try:
        bootctl_output = subprocess.check_output(["bootctl", "status"], text=True)
        match = re.search(
            r"^\s*id:\s+.*obsidian-([ab])\.conf", bootctl_output, re.MULTILINE
        )
        if match:
            return match.group(1)
    except (subprocess.CalledProcessError, FileNotFoundError):
        pass
    return "unknown"


def get_current_slot():
    try:
        findmnt_output = subprocess.check_output(
            ["findmnt", "-n", "-o", "SOURCE,UUID,PARTUUID,LABEL,PARTLABEL", "/"],
            text=True,
        ).strip()
        for item in findmnt_output.split():
            if "_a" in item:
                return "a"
            elif "_b" in item:
                return "b"

    except (subprocess.CalledProcessError, FileNotFoundError):
        pass
    return "unknown"


def handle_status(args):
    logo = [
    "       \033[0;36m.        \033[0;37m",
    "      \033[0;36m/\033[35m \\       \033[0;37m",
    "     \033[0;36m/ \033[35m  \\      \033[1;37m",
    "    \033[0;36m/^.\033[35m   \\     \033[1;37m",
    "   \033[0;36m/  .\033[35m-.  \\    \033[1;37m",
    "  \033[0;36m/  (\033[35m   ) _\\   \033[1;37m",
    " \033[1;36m/ _.~\033[35m   ~._^\\  \033[0;37m",
    "\033[1;36m/.^   \033[35m      ^.\\ \033[0;37m"
    ]

    info = {}
    info["Active Slot"] = get_current_slot_systemd()
    info["Current Slot"] = get_current_slot()
    info["Kernel"] = run_command(
        "uname -r", capture_output=True, text=True
    ).stdout.strip()
    info["Uptime"] = (
        run_command("uptime -p", capture_output=True, text=True)
        .stdout.strip()
        .replace("up ", "")
    )
    try:
        with open("/etc/os-release") as f:
            os_release = dict(line.strip().split("=", 1) for line in f if "=" in line)
        info["OS"] = os_release.get("PRETTY_NAME", "GNU/Linux").strip('"')
    except FileNotFoundError:
        info["OS"] = "GNU/Linux"

    info["Hostname"] = run_command(
        "hostnamectl hostname", capture_output=True, text=True
    ).stdout.strip()
    cpu_info = run_command("lscpu", capture_output=True, text=True).stdout
    cpu_model_match = re.search(r"Model name:\s+(.*)", cpu_info)
    if cpu_model_match:
        info["CPU"] = cpu_model_match.group(1).strip()

    mem_info = run_command("free -h", capture_output=True, text=True).stdout
    mem_line = mem_info.split("\n")[1]
    mem_parts = mem_line.split()
    if len(mem_parts) >= 3:
        info["Memory"] = f"{mem_parts[2]} / {mem_parts[1]}"

    max_logo_width = max(len(line) for line in logo)
    for i in range(max(len(logo), len(info))):
        logo_line = logo[i] if i < len(logo) else " " * max_logo_width
        if i < len(info):
            key, value = list(info.items())[i]
            info_line = f"\033[1m{key}\033[0m: {value}"
        else:
            info_line = ""

        print(f"{logo_line}  {info_line}")
    print("\n\033[1mPartition Information:\033[0m")
    run_command("lsblk -o NAME,LABEL,SIZE,MOUNTPOINT")


def handle_dual_boot(args):
    checkroot()
    device = args.device
    system_sfs = args.system_sfs

    if not os.path.exists(device):
        print(f"Error: Device '{device}' does not exist.", file=sys.stderr)
        sys.exit(1)

    if not os.path.exists(system_sfs):
        print(f"Error: System image '{system_sfs}' not found.", file=sys.stderr)
        sys.exit(1)

    print(
        f"WARNING: This will install ObsidianOS on {device} alongside your existing OS."
    )
    print("Please ensure you have enough free space on the device.")
    confirm = input("Are you sure you want to proceed? (y/N): ")
    if confirm.lower() != "y":
        print("Installation aborted.")
        sys.exit(0)

    print("Partitioning device...")
    partition_table = f"""
label: gpt
,{args.esp_size},U,*
,{args.esp_size},U,*
,{args.rootfs_size},L,*
,{args.rootfs_size},L,*
,{args.etc_size},L,*
,{args.var_size},L,*
,,L,*
"""
    run_command(f"sfdisk --append {device}", input=partition_table, text=True)
    run_command("partprobe", check=False)
    print("Waiting for device partitions to settle...")
    run_command("udevadm settle")

    part_num = (
        int(
            run_command(
                f"bash -c \"lsblk -l -n -o MAJ:MIN,NAME | grep '{os.path.basename(device)}' | wc -l\"",
                capture_output=True,
                text=True,
            ).stdout.strip()
        )
        - 1
    )

    part1, part2, part3, part4, part5, part6, part7 = (
        _get_part_path(device, part_num - 6),
        _get_part_path(device, part_num - 5),
        _get_part_path(device, part_num - 4),
        _get_part_path(device, part_num - 3),
        _get_part_path(device, part_num - 2),
        _get_part_path(device, part_num - 1),
        _get_part_path(device, part_num),
    )

    print("Formatting partitions...")
    format_commands = [
        f"mkfs.fat -F32 -n ESP_A {part1}",
        f"mkfs.fat -F32 -n ESP_B {part2}",
        f"mkfs.ext4 -F -L root_a {part3}",
        f"mkfs.ext4 -F -L root_b {part4}",
        f"mkfs.ext4 -F -L etc_ab {part5}",
        f"mkfs.ext4 -F -L var_ab {part6}",
        f"mkfs.ext4 -F -L home_ab {part7}",
    ]
    for cmd in format_commands:
        run_command(cmd)

    mount_dir = "/mnt/obsidian_install"
    run_command(f"mkdir -p {mount_dir}")
    print("Mounting root partition for slot 'a'...")
    run_command(f"mount /dev/disk/by-label/root_a {mount_dir}")
    print(f"Extracting system from {system_sfs} to slot 'a'...")
    run_command(f"unsquashfs -f -d {mount_dir} -no-xattrs {system_sfs}")
    print("Generating fstab for slot 'a'...")
    fstab_content_a = """
LABEL=root_a  /      ext4  defaults,noatime 0 1
LABEL=ESP_A     /boot  vfat  defaults,noatime 0 2
LABEL=etc_ab  /etc   ext4  defaults,noatime 0 2
LABEL=var_ab  /var   ext4  defaults,noatime 0 2
LABEL=home_ab /home  ext4  defaults,noatime 0 2
"""
    with open(f"{mount_dir}/etc/fstab", "w") as f:
        f.write(fstab_content_a.strip())

    print("Populating shared /etc, /var, and /home partitions...")
    for part_label in ["etc_ab", "var_ab", "home_ab"]:
        fs_dir = part_label.split("_")[0]
        tmp_mount_dir = f"/mnt/tmp_{fs_dir}"
        run_command(f"mkdir -p {tmp_mount_dir}")
        try:
            run_command(f"mount /dev/disk/by-label/{part_label} {tmp_mount_dir}")
            run_command(f"rsync -aK --delete {mount_dir}/{fs_dir}/ {tmp_mount_dir}/")
        finally:
            run_command(f"umount {tmp_mount_dir}", check=False)
            run_command(f"rmdir {tmp_mount_dir}", check=False)

    print("Populating ESP with boot files from system image...")
    esp_tmp_mount = "/mnt/obsidian_esp_tmp"
    run_command(f"mkdir -p {esp_tmp_mount}")
    try:
        run_command(f"mount /dev/disk/by-label/ESP_A {esp_tmp_mount}")
        run_command(f"rsync -aK --delete {mount_dir}/boot/ {esp_tmp_mount}/")
    finally:
        run_command(f"umount {esp_tmp_mount}", check=False)
        run_command(f"rmdir {esp_tmp_mount}", check=False)

    print("Populating ESP_B with boot files from system image...")
    esp_b_tmp_mount = "/mnt/obsidian_esp_b_tmp"
    run_command(f"mkdir -p {esp_b_tmp_mount}")
    try:
        run_command(f"mount /dev/disk/by-label/ESP_B {esp_b_tmp_mount}")
        run_command(f"rsync -aK --delete {mount_dir}/boot/ {esp_b_tmp_mount}/")
    finally:
        run_command(f"umount {esp_b_tmp_mount}", check=False)
        run_command(f"rmdir {esp_b_tmp_mount}", check=False)

    print("Mounting shared partitions for potential chroot...")
    mount_commands = [
        f"mkdir -p {mount_dir}/boot",
        f"mkdir -p {mount_dir}/etc",
        f"mkdir -p {mount_dir}/var",
        f"mkdir -p {mount_dir}/home",
        f"mount /dev/disk/by-label/ESP_A {mount_dir}/boot",
        f"mount /dev/disk/by-label/etc_ab {mount_dir}/etc",
        f"mount /dev/disk/by-label/var_ab {mount_dir}/var",
        f"mount /dev/disk/by-label/home_ab {mount_dir}/home",
    ]
    for cmd in mount_commands:
        run_command(cmd)

    print("Copying support files to slot 'a'...")
    script_path = os.path.realpath(sys.argv[0])
    os_release_path = "/etc/os-release"
    obsidianctl_dest = f"{mount_dir}/usr/bin/obsidianctl"
    if os.path.exists(f"{mount_dir}/obsidianctl-aur-installed"):
        print(
            "obsidianctl has been installed through the AUR. Skipping obsidianctl copy..."
        )
    else:
        run_command(f"mkdir -p {mount_dir}/usr/bin")
        run_command(f"cp {script_path} {obsidianctl_dest}")
        run_command(f"chmod +x {obsidianctl_dest}")
    if os.path.exists(os_release_path):
        run_command(f"cp {os_release_path} {mount_dir}/etc/os-release")
    else:
        print(
            f"Warning: os-release file not found at {os_release_path}. Skipping.",
            file=sys.stderr,
        )

    print("\nSlot 'a' is now configured and mounted.")
    chroot_confirm = input(
        "Do you want to chroot into slot 'a' to make changes before copying it to slot B? (y/N): "
    )
    if chroot_confirm.lower() == "y":
        print(f"Entering chroot environment in {mount_dir}...")
        print(
            "Common tasks: passwd, ln -sf /usr/share/zoneinfo/Region/City /etc/localtime, useradd"
        )
        print("Type 'exit' or press Ctrl+D when you are finished.")
        run_command(f"arch-chroot {mount_dir}", check=False)
        print("Exited chroot.")

    print("Unmounting slot 'a' partitions before copy...")
    run_command(f"umount -R {mount_dir}")
    print("Copying system to slot 'b'...")
    run_command(f"dd if={part3} of={part4} bs=16M status=progress")
    run_command(f"e2label {part4} root_b")
    print("Correcting fstab for slot 'b'...")
    mount_b_dir = "/mnt/obsidian_install_b"
    run_command(f"mkdir -p {mount_b_dir}")
    try:
        run_command(f"mount {part4} {mount_b_dir}")
        fstab_b_path = f"{mount_b_dir}/etc/fstab"
        if not os.path.exists(os.path.dirname(fstab_b_path)):
            run_command(f"mkdir -p {os.path.dirname(fstab_b_path)}")
        fstab_content_b = fstab_content_a.replace(
            "LABEL=root_a", "LABEL=root_b"
        ).replace("LABEL=ESP_A", "LABEL=ESP_B")
        with open(fstab_b_path, "w") as f:
            f.write(fstab_content_b)
    finally:
        run_command(f"umount {mount_b_dir}", check=False)
        run_command(f"rm -r {mount_b_dir}", check=False)

    print("Installing systemd-boot to ESP_A...")
    esp_a_mount_dir = "/mnt/obsidian_esp_a"
    run_command(f"mkdir -p {esp_a_mount_dir}")
    try:
        run_command(f"mount {part1} {esp_a_mount_dir}")
        run_command(
            f'bootctl --esp-path={esp_a_mount_dir} --efi-boot-option-description="ObsidianOS (Slot A)" install'
        )
    finally:
        run_command(f"umount {esp_a_mount_dir}", check=False)
        run_command(f"rm -r {esp_a_mount_dir}", check=False)

    print("Installing systemd-boot to ESP_B...")
    esp_b_mount_dir = "/mnt/obsidian_esp_b"
    run_command(f"mkdir -p {esp_b_mount_dir}")
    try:
        run_command(f"mount {part2} {esp_b_mount_dir}")
        run_command(
            f'bootctl --esp-path={esp_b_mount_dir} --efi-boot-option-description="ObsidianOS (Slot B)" install'
        )
    finally:
        run_command(f"umount {esp_b_mount_dir}", check=False)
        run_command(f"rm -r {esp_b_mount_dir}", check=False)

    root_a_partuuid = run_command(
        f"blkid -s PARTUUID -o value {part3}", capture_output=True, text=True
    ).stdout.strip()
    root_b_partuuid = run_command(
        f"blkid -s PARTUUID -o value {part4}", capture_output=True, text=True
    ).stdout.strip()
    if not root_a_partuuid or not root_b_partuuid:
        print(
            "Could not determine PARTUUIDs for root partitions. Cannot create boot entries.",
            file=sys.stderr,
        )
        sys.exit(1)

    loader_conf = """
timeout 3
default obsidian-a.conf
"""
    entry_a_conf = f"""
title ObsidianOS (Slot A)
linux /vmlinuz-linux
initrd /initramfs-linux.img
options root=PARTUUID={root_a_partuuid} rw
"""
    entry_b_conf = f"""
title ObsidianOS (Slot B)
linux /vmlinuz-linux
initrd /initramfs-linux.img
options root=PARTUUID={root_b_partuuid} rw
"""

    esp_a_config_mount_dir = "/mnt/obsidian_esp_a_config"
    run_command(f"mkdir -p {esp_a_config_mount_dir}")
    try:
        run_command(f"mount {part1} {esp_a_config_mount_dir}")
        run_command(f"mkdir -p {esp_a_config_mount_dir}/loader/entries")
        with open(f"{esp_a_config_mount_dir}/loader/loader.conf", "w") as f:
            f.write(loader_conf)
        with open(f"{esp_a_config_mount_dir}/loader/entries/obsidian-a.conf", "w") as f:
            f.write(entry_a_conf)
        with open(f"{esp_a_config_mount_dir}/loader/entries/obsidian-b.conf", "w") as f:
            f.write(entry_b_conf)
    finally:
        run_command(f"umount {esp_a_config_mount_dir}", check=False)
        run_command(f"rm -r {esp_a_config_mount_dir}", check=False)

    print("Writing boot configuration to ESP_B...")
    esp_b_config_mount_dir = "/mnt/obsidian_esp_b_config"
    run_command(f"mkdir -p {esp_b_config_mount_dir}")
    try:
        run_command(f"mount {part2} {esp_b_config_mount_dir}")
        run_command(f"mkdir -p {esp_b_config_mount_dir}/loader/entries")
        with open(f"{esp_b_config_mount_dir}/loader/loader.conf", "w") as f:
            f.write(loader_conf)
        with open(f"{esp_b_config_mount_dir}/loader/entries/obsidian-a.conf", "w") as f:
            f.write(entry_a_conf)
        with open(f"{esp_b_config_mount_dir}/loader/entries/obsidian-b.conf", "w") as f:
            f.write(entry_b_conf)
    finally:
        run_command(f"umount {esp_b_config_mount_dir}", check=False)
        run_command(f"rm -r {esp_b_config_mount_dir}", check=False)

    print("Detecting other operating systems...")
    esp_a_config_mount_dir = "/mnt/obsidian_esp_a_config"
    esp_b_config_mount_dir = "/mnt/obsidian_esp_b_config"
    run_command(f"mkdir -p {esp_a_config_mount_dir}")
    run_command(f"mkdir -p {esp_b_config_mount_dir}")
    try:
        run_command(f"mount {part1} {esp_a_config_mount_dir}")
        run_command(f"mount {part2} {esp_b_config_mount_dir}")
        os_prober_output = run_command(
            "os-prober", capture_output=True, text=True
        ).stdout.strip()
        if os_prober_output:
            print("Found other operating systems:")
            print(os_prober_output)
            esp_a_entries_path = f"{esp_a_config_mount_dir}/loader/entries"
            esp_b_entries_path = f"{esp_b_config_mount_dir}/loader/entries"
            for i, line in enumerate(os_prober_output.splitlines()):
                parts = line.split(":")
                if len(parts) >= 3:
                    device_path = parts[0]
                    os_name = parts[1]
                    entry_filename = f"50-other-os-{i}.conf"
                    entry_content = f"""title {os_name}
efi {device_path}
"""
                    with open(f"{esp_a_entries_path}/{entry_filename}", "w") as f:
                        f.write(entry_content)
                    with open(f"{esp_b_entries_path}/{entry_filename}", "w") as f:
                        f.write(entry_content)
                    print(f"Created boot entry for {os_name}")

        else:
            print("No other operating systems found.")
    except Exception as e:
        print(f"Error running os-prober: {e}")
        print("Please make sure os-prober is installed.")
    finally:
        run_command(f"umount {esp_a_config_mount_dir}", check=False)
        run_command(f"rm -r {esp_a_config_mount_dir}", check=False)
        run_command(f"umount {esp_b_config_mount_dir}", check=False)
        run_command(f"rm -r {esp_b_config_mount_dir}", check=False)

    run_command(f"rm -r {mount_dir}", check=False)
    print("\nInstallation complete!")
    print("Default boot order will attempt Slot A, then Slot B.")
    print("Reboot your system to apply changes.")


def handle_mkobsidiansfs(args):
    if shutil.which("mkobsidiansfs"):
        os.system(f"mkobsidiansfs {args.system_sfs}")
    else:
        if shutil.which("git"):
            os.system(f"git clone https://github.com/Obsidian-OS/mkobsidiansfs/ /tmp/mkobsidiansfs;chmod u+x /tmp/mkobsidiansfs/mkobsidiansfs;/tmp/mkobsidiansfs/mkobsidiansfs {args.system_sfs} tmp_system.sfs")
        else:
            print("No git or mkobsidiansfs found. Please install one of these to directly pass in an .mkobsfs.")
            sys.exit(1)
    args.system_sfs="tmp_system.sfs"
    handle_install(args)
    os.remove("tmp_system.sfs")
    
def handle_install(args):
    if args.dual_boot:
        handle_dual_boot(args)
        return

    checkroot()
    device = args.device
    system_sfs = args.system_sfs or '/etc/system.sfs'
    _, ext = os.path.splitext(system_sfs)
    if ext==".mkobsfs":
        handle_mkobsidiansfs(args)
        sys.exit()
    
    if not os.path.exists(device):
        print(f"Error: Device '{device}' does not exist.", file=sys.stderr)
        sys.exit(1)

    if not os.path.exists(system_sfs):
        print(f"Error: System image '{system_sfs}' not found.", file=sys.stderr)
        sys.exit(1)

    print(f"WARNING: This will destroy all data on {device}.")
    confirm = input("Are you sure you want to proceed? (y/N): ")
    if confirm.lower() != "y":
        print("Installation aborted.")
        sys.exit(0)
    print("Partitioning device...")
    partition_table = f"""
label: gpt
,{args.esp_size},U,*
,{args.esp_size},U,*
,{args.rootfs_size},L,*
,{args.rootfs_size},L,*
,{args.etc_size},L,*
,{args.var_size},L,*
,,L,*
"""
    run_command(f"sfdisk {device}", input=partition_table, text=True)
    run_command("partprobe", check=False)
    print("Waiting for device partitions to settle...")
    run_command("udevadm settle")
    part1, part2, part3, part4, part5, part6, part7 = (
        _get_part_path(device, 1),
        _get_part_path(device, 2),
        _get_part_path(device, 3),
        _get_part_path(device, 4),
        _get_part_path(device, 5),
        _get_part_path(device, 6),
        _get_part_path(device, 7),
    )

    print("Formatting partitions...")
    format_commands = [
        f"mkfs.fat -F32 -n ESP_A {part1}",
        f"mkfs.fat -F32 -n ESP_B {part2}",
        f"mkfs.ext4 -F -L root_a {part3}",
        f"mkfs.ext4 -F -L root_b {part4}",
        f"mkfs.ext4 -F -L etc_ab {part5}",
        f"mkfs.ext4 -F -L var_ab {part6}",
        f"mkfs.ext4 -F -L home_ab {part7}",
    ]
    for cmd in format_commands:
        run_command(cmd)

    mount_dir = "/mnt/obsidian_install"
    run_command(f"mkdir -p {mount_dir}")
    print("Mounting root partition for slot 'a'...")
    run_command(f"mount /dev/disk/by-label/root_a {mount_dir}")
    print(f"Extracting system from {system_sfs} to slot 'a'...")
    run_command(f"unsquashfs -f -d {mount_dir} -no-xattrs {system_sfs}")
    print("Generating fstab for slot 'a'...")
    fstab_content_a = """
LABEL=root_a  /      ext4  defaults,noatime 0 1
LABEL=ESP_A     /boot  vfat  defaults,noatime 0 2
LABEL=etc_ab  /etc   ext4  defaults,noatime 0 2
LABEL=var_ab  /var   ext4  defaults,noatime 0 2
LABEL=home_ab /home  ext4  defaults,noatime 0 2
"""
    with open(f"{mount_dir}/etc/fstab", "w") as f:
        f.write(fstab_content_a.strip())

    print("Populating shared /etc, /var, and /home partitions...")
    for part_label in ["etc_ab", "var_ab", "home_ab"]:
        fs_dir = part_label.split("_")[0]
        tmp_mount_dir = f"/mnt/tmp_{fs_dir}"
        run_command(f"mkdir -p {tmp_mount_dir}")
        try:
            run_command(f"mount /dev/disk/by-label/{part_label} {tmp_mount_dir}")
            run_command(f"rsync -aK --delete {mount_dir}/{fs_dir}/ {tmp_mount_dir}/")
        finally:
            run_command(f"umount {tmp_mount_dir}", check=False)
            run_command(f"rmdir {tmp_mount_dir}", check=False)

    print("Populating ESP with boot files from system image...")
    esp_tmp_mount = "/mnt/obsidian_esp_tmp"
    run_command(f"mkdir -p {esp_tmp_mount}")
    try:
        run_command(f"mount /dev/disk/by-label/ESP_A {esp_tmp_mount}")
        run_command(f"rsync -aK --delete {mount_dir}/boot/ {esp_tmp_mount}/")
    finally:
        run_command(f"umount {esp_tmp_mount}", check=False)
        run_command(f"rmdir {esp_tmp_mount}", check=False)

    print("Populating ESP_B with boot files from system image...")
    esp_b_tmp_mount = "/mnt/obsidian_esp_b_tmp"
    run_command(f"mkdir -p {esp_b_tmp_mount}")
    try:
        run_command(f"mount /dev/disk/by-label/ESP_B {esp_b_tmp_mount}")
        run_command(f"rsync -aK --delete {mount_dir}/boot/ {esp_b_tmp_mount}/")
    finally:
        run_command(f"umount {esp_b_tmp_mount}", check=False)
        run_command(f"rmdir {esp_b_tmp_mount}", check=False)

    print("Mounting shared partitions for potential chroot...")
    mount_commands = [
        f"mkdir -p {mount_dir}/boot",
        f"mkdir -p {mount_dir}/etc",
        f"mkdir -p {mount_dir}/var",
        f"mkdir -p {mount_dir}/home",
        f"mount /dev/disk/by-label/ESP_A {mount_dir}/boot",
        f"mount /dev/disk/by-label/etc_ab {mount_dir}/etc",
        f"mount /dev/disk/by-label/var_ab {mount_dir}/var",
        f"mount /dev/disk/by-label/home_ab {mount_dir}/home",
    ]
    for cmd in mount_commands:
        run_command(cmd)

    print("Copying support files to slot 'a'...")
    script_path = os.path.realpath(sys.argv[0])
    os_release_path = "/etc/os-release"
    obsidianctl_dest = f"{mount_dir}/usr/bin/obsidianctl"
    if os.path.exists(f"{mount_dir}/obsidianctl-aur-installed"):
        print("obsidianctl has been installed through the AUR. Skipping obsidianctl copy...")
    else:
        run_command(f"mkdir -p {mount_dir}/usr/bin")
        run_command(f"cp {script_path} {obsidianctl_dest}")
        run_command(f"chmod +x {obsidianctl_dest}")
    if os.path.exists(os_release_path):
        run_command(f"cp {os_release_path} {mount_dir}/etc/os-release")
    else:
        print(
            f"Warning: os-release file not found at {os_release_path}. Skipping.",
            file=sys.stderr,
        )

    print("\nSlot 'a' is now configured and mounted.")
    chroot_confirm = input(
        "Do you want to chroot into slot 'a' to make changes before copying it to slot B? (y/N): "
    )
    if chroot_confirm.lower() == "y":
        print(f"Entering chroot environment in {mount_dir}...")
        print(
            "Common tasks: passwd, ln -sf /usr/share/zoneinfo/Region/City /etc/localtime, useradd"
        )
        print("Type 'exit' or press Ctrl+D when you are finished.")
        run_command(f"arch-chroot {mount_dir}", check=False)
        print("Exited chroot.")

    print("Unmounting slot 'a' partitions before copy...")
    run_command(f"umount -R {mount_dir}")
    print("Copying system to slot 'b'...")
    run_command(f"dd if={part3} of={part4} bs=16M status=progress")
    run_command(f"e2label {part4} root_b")
    print("Correcting fstab for slot 'b'...")
    mount_b_dir = "/mnt/obsidian_install_b"
    run_command(f"mkdir -p {mount_b_dir}")
    try:
        run_command(f"mount {part4} {mount_b_dir}")
        fstab_b_path = f"{mount_b_dir}/etc/fstab"
        if not os.path.exists(os.path.dirname(fstab_b_path)):
            run_command(f"mkdir -p {os.path.dirname(fstab_b_path)}")
        fstab_content_b = fstab_content_a.replace(
            "LABEL=root_a", "LABEL=root_b"
        ).replace("LABEL=ESP_A", "LABEL=ESP_B")
        with open(fstab_b_path, "w") as f:
            f.write(fstab_content_b)
    finally:
        run_command(f"umount {mount_b_dir}", check=False)
        run_command(f"rm -r {mount_b_dir}")

    print("Installing systemd-boot to ESP_A...")
    esp_a_mount_dir = "/mnt/obsidian_esp_a"
    run_command(f"mkdir -p {esp_a_mount_dir}")
    try:
        run_command(f"mount {part1} {esp_a_mount_dir}")
        run_command(f"bootctl --esp-path={esp_a_mount_dir} --efi-boot-option-description=\"ObsidianOS (Slot A)\" install")
    finally:
        run_command(f"umount {esp_a_mount_dir}", check=False)
        run_command(f"rm -r {esp_a_mount_dir}", check=False)

    print("Installing systemd-boot to ESP_B...")
    esp_b_mount_dir = "/mnt/obsidian_esp_b"
    run_command(f"mkdir -p {esp_b_mount_dir}")
    try:
        run_command(f"mount {part2} {esp_b_mount_dir}")
        run_command(f"bootctl --esp-path={esp_b_mount_dir} --efi-boot-option-description=\"ObsidianOS (Slot B)\" install")
    finally:
        run_command(f"umount {esp_b_mount_dir}", check=False)
        run_command(f"rm -r {esp_b_mount_dir}", check=False)

    root_a_partuuid = run_command(
        f"blkid -s PARTUUID -o value {part3}", capture_output=True, text=True
    ).stdout.strip()
    root_b_partuuid = run_command(
        f"blkid -s PARTUUID -o value {part4}", capture_output=True, text=True
    ).stdout.strip()
    if not root_a_partuuid or not root_b_partuuid:
        print(
            "Could not determine PARTUUIDs for root partitions. Cannot create boot entries.",
            file=sys.stderr,
        )
        sys.exit(1)

    loader_conf = """
timeout 0
default obsidian-a.conf
"""
    entry_a_conf = f"""
title ObsidianOS (Slot A)
linux /vmlinuz-linux
initrd /initramfs-linux.img
options root=PARTUUID={root_a_partuuid} rw
"""
    entry_b_conf = f"""
title ObsidianOS (Slot B)
linux /vmlinuz-linux
initrd /initramfs-linux.img
options root=PARTUUID={root_b_partuuid} rw
"""

    esp_a_config_mount_dir = "/mnt/obsidian_esp_a_config"
    run_command(f"mkdir -p {esp_a_config_mount_dir}")
    try:
        run_command(f"mount {part1} {esp_a_config_mount_dir}")
        run_command(f"mkdir -p {esp_a_config_mount_dir}/loader/entries")
        with open(f"{esp_a_config_mount_dir}/loader/loader.conf", "w") as f:
            f.write(loader_conf)
        with open(f"{esp_a_config_mount_dir}/loader/entries/obsidian-a.conf", "w") as f:
            f.write(entry_a_conf)
        with open(f"{esp_a_config_mount_dir}/loader/entries/obsidian-b.conf", "w") as f:
            f.write(entry_b_conf)
    finally:
        run_command(f"umount {esp_a_config_mount_dir}", check=False)
        run_command(f"rm -r {esp_a_config_mount_dir}", check=False)

    print("Writing boot configuration to ESP_B...")
    esp_b_config_mount_dir = "/mnt/obsidian_esp_b_config"
    run_command(f"mkdir -p {esp_b_config_mount_dir}")
    try:
        run_command(f"mount {part2} {esp_b_config_mount_dir}")
        run_command(f"mkdir -p {esp_b_config_mount_dir}/loader/entries")
        with open(f"{esp_b_config_mount_dir}/loader/loader.conf", "w") as f:
            f.write(loader_conf)
        with open(f"{esp_b_config_mount_dir}/loader/entries/obsidian-a.conf", "w") as f:
            f.write(entry_a_conf)
        with open(f"{esp_b_config_mount_dir}/loader/entries/obsidian-b.conf", "w") as f:
            f.write(entry_b_conf)
    finally:
        run_command(f"umount {esp_b_config_mount_dir}", check=False)
        run_command(f"rm -r {esp_b_config_mount_dir}", check=False)
    run_command(f"rm -r {mount_dir}", check=False)
    print("\nInstallation complete!")
    print("Default boot order will attempt Slot A, then Slot B.")
    print("Reboot your system to apply changes.")


def handle_switch(args):
    checkroot()
    slot = args.slot
    print(f"Switching active boot slot to '{slot}'...")
    esp_a_path = "/dev/disk/by-label/ESP_A"
    esp_b_path = "/dev/disk/by-label/ESP_B"
    if not os.path.exists(esp_a_path) or not os.path.exists(esp_b_path):
        print(
            "ESP partitions not found. Was the system installed with obsidianctl?",
            file=sys.stderr,
        )
        sys.exit(1)

    esp_mount_dir = "/mnt/obsidian_esp_tmp"
    run_command(f"mkdir -p {esp_mount_dir}")
    try:
        run_command(f"mount {esp_a_path} {esp_mount_dir}")
        run_command(
            f"bootctl --esp-path={esp_mount_dir} set-default obsidian-{slot}.conf"
        )
        print(f"Default boot entry set to obsidian-{slot}.conf on ESP_A.")
    finally:
        run_command(f"umount {esp_mount_dir}", check=False)

    try:
        run_command(f"mount {esp_b_path} {esp_mount_dir}")
        run_command(
            f"bootctl --esp-path={esp_mount_dir} set-default obsidian-{slot}.conf"
        )
        print(f"Default boot entry set to obsidian-{slot}.conf on ESP_B.")
    finally:
        run_command(f"umount {esp_mount_dir}", check=False)
        run_command(f"rm -r {esp_mount_dir}", check=False)

    print(f"Active boot slot switched to '{slot}'. The change is persistent.")
    
def handle_switchonce(args):
    checkroot()
    slot = args.slot
    print(f"Switching active boot slot to '{slot}' temporarily...")
    esp_a_path = "/dev/disk/by-label/ESP_A"
    esp_b_path = "/dev/disk/by-label/ESP_B"
    if not os.path.exists(esp_a_path) or not os.path.exists(esp_b_path):
        print(
            "ESP partitions not found. Was the system installed with obsidianctl?",
            file=sys.stderr,
        )
        sys.exit(1)

    esp_mount_dir = "/mnt/obsidian_esp_tmp"
    run_command(f"mkdir -p {esp_mount_dir}")
    try:
        run_command(f"mount {esp_a_path} {esp_mount_dir}")
        run_command(
            f"bootctl --esp-path={esp_mount_dir} set-oneshot obsidian-{slot}.conf"
        )
        print(f"Default boot entry set to obsidian-{slot}.conf on ESP_A.")
    finally:
        run_command(f"umount {esp_mount_dir}", check=False)

    try:
        run_command(f"mount {esp_b_path} {esp_mount_dir}")
        run_command(
            f"bootctl --esp-path={esp_mount_dir} set-oneshot obsidian-{slot}.conf"
        )
        print(f"Default boot entry set to obsidian-{slot}.conf on ESP_B.")
    finally:
        run_command(f"umount {esp_mount_dir}", check=False)
        run_command(f"rm -r {esp_mount_dir}", check=False)

    print(f"Active boot slot switched to '{slot}'. The change is temporarily.")


def handle_update(args):
    checkroot()
    slot = args.slot
    system_sfs = args.system_sfs
    if not os.path.exists(system_sfs):
        print(f"Error: System image '{system_sfs}' not found.", file=sys.stderr)
        sys.exit(1)

    target_label = f"root_{slot}"
    esp_label = f"ESP_{slot}"
    print(f"Updating slot '{slot}' with image '{system_sfs}'...")
    print(f"WARNING: THIS WILL ERASE ALL OF SLOT {slot.upper()}. INCLUDING /root.")
    confirm = input("Continue? (y/N): ")
    if confirm.lower() != "y":
        print("Operation Canceled.")
        exit(1)
    print("Formatting partition...")
    run_command(f"mkfs.ext4 -F -L {target_label} /dev/disk/by-label/{target_label}")
    mount_dir = f"/mnt/obsidian_update_{slot}"
    run_command(f"mkdir -p {mount_dir}")
    try:
        print(f"Mounting partition for slot '{slot}'...")
        run_command(f"mount /dev/disk/by-label/{target_label} {mount_dir}")
        print(f"Extracting system from {system_sfs} to slot '{slot}'...")
        run_command(f"unsquashfs -f -d {mount_dir} -no-xattrs {system_sfs}")
        print(f"Generating fstab for slot '{slot}'...")
        fstab_content = f"""
LABEL={target_label}  /      ext4  defaults,noatime 0 1
LABEL={esp_label}     /boot  vfat  defaults,noatime 0 2
LABEL=etc_ab  /etc   ext4  defaults,noatime 0 2
LABEL=var_ab  /var   ext4  defaults,noatime 0 2
LABEL=home_ab /home  ext4  defaults,noatime 0 2
"""
        fstab_path = f"{mount_dir}/etc/fstab"
        if not os.path.exists(os.path.dirname(fstab_path)):
            run_command(f"mkdir -p {os.path.dirname(fstab_path)}")

        with open(fstab_path, "w") as f:
            f.write(fstab_content.strip())
        print(f"Copying support files to slot '{slot}'...")
        script_path = os.path.realpath(sys.argv[0])
        obsidianctl_dest = f"{mount_dir}/usr/bin/obsidianctl"
        run_command(f"mkdir -p {mount_dir}/usr/bin")
        run_command(f"cp {script_path} {obsidianctl_dest}")
        run_command(f"chmod +x {obsidianctl_dest}")
        run_command(f"cp /etc/os-release {mount_dir}/etc/os-release")

        print(f"Populating ESP_{slot.upper()} with new boot files...")
        esp_tmp_mount = "/mnt/obsidian_esp_tmp"
        run_command(f"mkdir -p {esp_tmp_mount}")
        try:
            run_command(f"mount /dev/disk/by-label/ESP_{slot.upper()} {esp_tmp_mount}")
            run_command(f"rsync -aK --delete {mount_dir}/boot/ {esp_tmp_mount}/")
        finally:
            run_command(f"umount {esp_tmp_mount}", check=False)
            run_command(f"rmdir {esp_tmp_mount}", check=False)

    finally:
        print("Unmounting partition...")
        run_command(f"umount -R {mount_dir}", check=False)
        run_command(f"rm -r {mount_dir}", check=False)

    print(f"Update for slot '{slot}' complete!")
    print("You may need to switch to this slot and reboot to use the updated system.")


def handle_sync(args):
    check_dependencies(
        ["findfs", "blkid", "dd", "tune2fs", "sgdisk", "lsblk", "e2label", "fatlabel"]
    )
    checkroot()
    target_slot = args.slot
    current_slot = get_current_slot()
    if target_slot == current_slot:
        print(f"Error: Cannot sync slot {current_slot} to itself.", file=sys.stderr)
        sys.exit(1)

    print(f"Current slot: {current_slot}")
    print(f"Target slot: {target_slot}")
    source_root_label = f"root_{current_slot.lower()}"
    target_root_label = f"root_{target_slot.lower()}"
    source_esp_label = f"ESP_{current_slot.upper()}"
    target_esp_label = f"ESP_{target_slot.upper()}"
    try:
        source_root_dev = run_command(
            f"findfs LABEL={source_root_label}", capture_output=True
        ).stdout.strip()
        target_root_dev = run_command(
            f"findfs LABEL={target_root_label}", capture_output=True
        ).stdout.strip()
        source_esp_dev = run_command(
            f"findfs LABEL={source_esp_label}", capture_output=True
        ).stdout.strip()
        target_esp_dev = run_command(
            f"findfs LABEL={target_esp_label}", capture_output=True
        ).stdout.strip()
    except subprocess.CalledProcessError as e:
        print(f"Error: Could not find partitions by label. {e}", file=sys.stderr)
        sys.exit(1)

    if not all([source_root_dev, target_root_dev, source_esp_dev, target_esp_dev]):
        print(
            "Error: Could not find one or more source or target partitions by label.",
            file=sys.stderr,
        )
        sys.exit(1)

    print(f"Source root device: {source_root_dev}")
    print(f"Target root device: {target_root_dev}")
    print(f"Source ESP device: {source_esp_dev}")
    print(f"Target ESP device: {target_esp_dev}")
    print("Reading original partition identifiers from target slot...")
    try:
        target_root_fs_uuid = run_command(
            f"blkid -s UUID -o value {target_root_dev}", capture_output=True
        ).stdout.strip()
        target_root_part_uuid = run_command(
            f"blkid -s PARTUUID -o value {target_root_dev}", capture_output=True
        ).stdout.strip()
        target_esp_part_uuid = run_command(
            f"blkid -s PARTUUID -o value {target_esp_dev}", capture_output=True
        ).stdout.strip()
    except subprocess.CalledProcessError as e:
        print(f"Error: Could not read partition identifiers. {e}", file=sys.stderr)
        sys.exit(1)
    if not all([target_root_fs_uuid, target_root_part_uuid, target_esp_part_uuid]):
        print(
            "Error: Could not read one or more original partition identifiers from the target slot.",
            file=sys.stderr,
        )
        sys.exit(1)

    print("Copying data from source root to target root. This may take a while...")
    run_command(f"dd if={source_root_dev} of={target_root_dev} bs=4M status=progress")
    print(f"Setting label of {target_root_dev} to {target_root_label}")
    run_command(f"e2label {target_root_dev} {target_root_label}")
    print("Restoring original filesystem identifier for the root partition...")
    run_command(f"tune2fs -U {target_root_fs_uuid} {target_root_dev}")
    print("Restoring original partition identifier for the root partition...")
    target_disk = run_command(
        f"lsblk -no pkname {target_root_dev}", capture_output=True
    ).stdout.strip()
    partition_number = "".join(filter(str.isdigit, target_root_dev.split("/")[-1]))
    run_command(
        f"sgdisk --partition-guid={partition_number}:{target_root_part_uuid} /dev/{target_disk}"
    )
    print("Copying data from source ESP to target ESP...")
    run_command(f"dd if={source_esp_dev} of={target_esp_dev} bs=1M status=progress")
    print(f"Setting label of {target_esp_dev} to {target_esp_label}")
    run_command(f"fatlabel {target_esp_dev} {target_esp_label}")
    print("Restoring original partition identifier for the ESP...")
    target_esp_disk = run_command(
        f"lsblk -no pkname {target_esp_dev}", capture_output=True
    ).stdout.strip()
    esp_partition_number = "".join(filter(str.isdigit, target_esp_dev.split("/")[-1]))
    run_command(
        f"sgdisk --partition-guid={esp_partition_number}:{target_esp_part_uuid} /dev/{target_esp_disk}"
    )
    print("Sync complete.")



import argparse
import sys
def main():
    parser = argparse.ArgumentParser(
        description="Install and manage A/B slot system with shared partitions on ObsidianOS.",
        formatter_class=argparse.RawTextHelpFormatter,
    )
    subparsers = parser.add_subparsers(dest="command", required=True)
    parser_status = subparsers.add_parser(
        "status", help="Show current active slot and system info."
    )
    parser_status.set_defaults(func=handle_status)

    parser_install = subparsers.add_parser(
        "install", help="Partition device and install system image."
    )
    parser_install.add_argument(
        "device", help="The target block device (e.g., /dev/sda)."
    )
    parser_install.add_argument("system_sfs", help="Path to the SquashFS system image. If you pass in an .mkobsfs file, it will download and run mkobsidiansfs.")
    parser_install.add_argument("--rootfs-size", default="5G", help="Size of the root partitions for slots a and b.")
    parser_install.add_argument("--etc-size", default="5G", help="Size of the shared etc partition.")
    parser_install.add_argument("--var-size", default="5G", help="Size of the shared var partition.")
    parser_install.add_argument("--esp-size", default="512M", help="Size of the ESP partitions for slots a and b.")
    parser_install.add_argument("--dual-boot", action="store_true", help="Setup a dual-boot configuration. (EXPERIMENTAL. USE AT YOUR OWN RISK.)")
    parser_install.set_defaults(func=handle_install)
    parser_switchonce = subparsers.add_parser(
      "switch-once", help="Switch active boot slot to 'a' or 'b' once only."
    )
    parser_switchonce.add_argument(
      "slot", choices=["a", "b"], help="The slot to make active for once."
    )
    parser_switchonce.set_defaults(func=handle_switchonce)
    parser_switch = subparsers.add_parser(
        "switch", help="Switch active boot slot to 'a' or 'b'."
    )
    parser_switch.add_argument(
        "slot", choices=["a", "b"], help="The slot to make active."
    )
    parser_switch.set_defaults(func=handle_switch)

    parser_update = subparsers.add_parser(
        "update", help="Update a slot with a new system image."
    )
    parser_update.add_argument(
        "slot", choices=["a", "b"], help="The slot to update."
    )
    parser_update.add_argument(
        "system_sfs", help="Path to the new SquashFS system image."
    )
    parser_update.set_defaults(func=handle_update)

    parser_sync = subparsers.add_parser(
        "sync", help="Sync one slot to another."
    )
    parser_sync.add_argument(
        "slot", choices=["a", "b"], help="The slot to sync to."
    )
    parser_sync.set_defaults(func=handle_sync)

    if len(sys.argv) == 1:
        parser.print_help(sys.stderr)
        sys.exit(1)

    args = parser.parse_args()
    args.func(args)

main()
